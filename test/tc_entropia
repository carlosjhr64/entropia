#! ruby
require 'test/unit'
require 'entropia'

class TestEntropia < Test::Unit::TestCase
  include ENTROPIA

  def test_001_new
    assert_nothing_raised(Exception) do
      e = Entropia.new
      assert_equal 0,      e.to_i
      assert_equal '',     e.to_s
      assert_equal 2,      e.base
      assert_equal 1,      e.entropy
      assert_equal 0.0,    e.bits
      assert_equal 0,      e.randomness
      assert_equal false,  e.shuffled?
      assert_equal BaseConvert::Configuration::WORD, e.digits
    end
    assert_nothing_raised(Exception) do
      e = Entropia.new '0000'
      assert_equal 0,      e.to_i
      assert_equal '0000', e.to_s
      assert_equal 2,      e.base
      assert_equal 2**4,   e.entropy
      assert_equal 4.0,    e.bits
      assert_equal 0,      e.randomness
      assert_equal false,  e.shuffled?
      assert_equal BaseConvert::Configuration::WORD, e.digits
    end
    assert_nothing_raised(Exception) do
      e = Entropia.new 1, entropy: 8, digits: 'ab'
      assert_equal 1,      e.to_i
      assert_equal 'aab',  e.to_s
      assert_equal 2,      e.base
      assert_equal 2**3,   e.entropy
      assert_equal 3.0,    e.bits
      assert_equal 0,      e.randomness
      assert_equal false,  e.shuffled?
      assert_equal 'ab',   e.digits
    end
  end

  def test_002_set_entropy
    e = Entropia.new
    assert_equal '', e.to_s

    e.set_entropy(2**16)
    assert_equal '0000000000000000', e.to_s
    assert_equal 2**16, e.entropy
    assert_equal 16.0, e.bits

    e = Entropia.new '', digits: '!+', shuffled: true
    assert_equal true, e.shuffled?

    e.set_entropy(2**16)
    assert_equal false, e.shuffled?
    assert_equal '!!!!!!!!!!!!!!!!', e.to_s
  end

  def test_003_set_bits
   e = Entropia.new
   assert_equal '', e.to_s

   e.set_bits(16)
   assert_equal 16.0, e.bits
   assert_equal '0000000000000000', e.to_s
   assert_equal 2**16, e.entropy
  end

  def test_004_increase
    e = Entropia.new base: 16
    assert_equal '', e.to_s

    e.increase!(3)
    assert_equal 3,     e.to_s.length
    assert_equal 16,    e.base
    assert_equal 0,     e.randomness
    assert_equal false, e.shuffled?
    assert_equal 16**3, e.entropy
    assert_equal 12.0,  e.bits

    e = Entropia.new(shuffled: true)
    assert_equal true, e.shuffled?
    e.increase!(4)
    assert_equal false, e.shuffled?
  end

  def test_005_pp # alias of increase
    a = Entropia.new
    a.p!
    b = Entropia.new
    b.p!
    assert_equal a, b
    assert_equal b, a

    b = b.p!
    e = a.p!
    assert_equal a, e
    assert_equal b, e

    assert_equal a.to_s, e.to_s
    assert_equal 2,      e.to_s.length
    assert_equal 2,      e.base
    assert_equal 0,      e.randomness
    assert_equal false,  e.shuffled?
    assert_equal 2**2,   e.entropy
    assert_equal 2.0,    e.bits

    assert_equal true, (a==e)
    a.set_shuffled true
    # Remember that a and e are the same instance
    assert_equal true, (a==e)
    # But b is a different instance.
    assert_equal false, (b==e)
  end

  def test_006_pp_rng
    rng = Object.new
    def rng.random_number(_); 10; end
    e = Entropia.new base: 16
    e.p!(6, random: rng)

    assert_equal 'AAAAAA', e.to_s
    assert_equal 16,       e.base
    # we assume rng is a source of randomness...
    assert_equal 24.0,     e.randomness
    assert_equal false,    e.shuffled?
    assert_equal 16**6,    e.entropy
    assert_equal 24.0,     e.bits
  end

  def test_008_convert_base
    e = Entropia.new.increase!(32, random: SecureRandom)
    assert_equal 16, H
    eh = e*H

    assert_equal 32, e.to_s.length
    assert_equal 8, eh.to_s.length
    # e and eh represent the same entropy
    assert_equal e, eh
    assert e==eh
  end

  def test_009_convert_base_conservation
    # Random.new(0) #radom_number(2) => 0,1,1,0,1,1,1,1
    e = E.new.p!(8, random: Random.new(0))
    # Remember that new entropia prepends the string...
    assert_equal '11110110', e.to_s
    eh = e*H # e*16
    assert_equal 2,     eh.to_s.length
    assert_equal 8,     eh.randomness
    assert_equal false, eh.shuffled?
    assert_equal 16,    eh.base
    assert_equal 2**8,  eh.entropy
    # '11110110'.to_i(2) == 246
    assert_equal 246, e.to_i
    assert_equal 246, eh.to_i
    # 246.to_s(16) == 'F6'.downcase
    assert_equal 'F6', eh.to_s
  end

  def test_010_concat_2_by_2
   #s0 = Entropia.new.increase(4, true){  0 }
   #s1 = Entropia.new.increase(4, false){ 1 }
   #s = nil
   #assert_nothing_raised(Exception){ s = s0 + s1 }
   #assert_equal 8,     s.length
   #assert_equal 2,     s.base
   #assert_equal 2**8,  s.entropy
   #assert_equal 4,     s.randomness
   #assert_equal false, s.shuffled
  end

  def test_011_concat_16_by_8
   #s0 = Entropia.new.increase(4)*16
   #assert_equal 16, s0.base
   #s1 = Entropia.new.increase(4)*8
   #assert_equal 8, s1.base

   #s01 = s0 + s1
   #assert_equal 16, s01.base
   #assert_equal 2,  s01.length

   #s10 = s1 + s0
   #assert_equal 8, s10.base
   #assert_equal 4, s10.length

   #assert_equal 2**8, s01.entropy
   #assert_equal 2**8, s10.entropy

   #assert_equal false, s01.shuffled
   #assert_equal false, s10.shuffled
  end

  def test_012_equal
   #s = Entropia.new.increase(16)
   #sh = s*16
   #so = s*8
   #assert sh == so
   #assert so == sh
  end

  def test_013_notation
   #s = E[256]
   #assert_equal 256, s.length

   #h = s*H
   #assert_equal 16, h.base

   #o = s*O
   #assert_equal 8, o.base

   #q = s*Q
   #assert_equal 91, q.base

   #w = s*W
   #assert_equal 62, w.base

   #assert h == o
   #assert q == o
   #assert q == w
  end

end
